{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EventManager = exports.EventWithContent = void 0;\nconst tslib_1 = require(\"tslib\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst i0 = tslib_1.__importStar(require(\"@angular/core\"));\nclass EventWithContent {\n  constructor(name, content) {\n    this.name = name;\n    this.content = content;\n  }\n}\nexports.EventWithContent = EventWithContent;\n/**\r\n * An utility class to manage RX events\r\n */\nclass EventManager {\n  constructor() {\n    this.observable = new rxjs_1.Observable(observer => {\n      this.observer = observer;\n    }).pipe((0, operators_1.share)());\n  }\n  /**\r\n   * Method to broadcast the event to observer\r\n   */\n  broadcast(event) {\n    if (this.observer) {\n      this.observer.next(event);\n    }\n  }\n  /**\r\n   * Method to subscribe to an event with callback\r\n   * @param eventNames  Single event name or array of event names to what subscribe\r\n   * @param callback    Callback to run when the event occurs\r\n   */\n  subscribe(eventNames, callback) {\n    if (typeof eventNames === 'string') {\n      eventNames = [eventNames];\n    }\n    return this.observable.pipe((0, operators_1.filter)(event => {\n      for (const eventName of eventNames) {\n        if (typeof event === 'string' && event === eventName || typeof event !== 'string' && event.name === eventName) {\n          return true;\n        }\n      }\n      return false;\n    })).subscribe(callback);\n  }\n  /**\r\n   * Method to unsubscribe the subscription\r\n   */\n  destroy(subscriber) {\n    subscriber.unsubscribe();\n  }\n}\nexports.EventManager = EventManager;\nEventManager.ɵfac = function EventManager_Factory(t) {\n  return new (t || EventManager)();\n};\nEventManager.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: EventManager,\n  factory: EventManager.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":";;;;;;;AACA;AACA;;AAEA,MAAaA,gBAAgB;EAC3BC,YAAmBC,IAAY,EAASC,OAAU;IAA/B,SAAI,GAAJD,IAAI;IAAiB,YAAO,GAAPC,OAAO;EAAM;;AADvDC;AAIA;;;AAGA,MAGaC,YAAY;EAIvBJ;IACE,IAAI,CAACK,UAAU,GAAG,IAAIC,iBAAU,CAAEC,QAAsD,IAAI;MAC1F,IAAI,CAACA,QAAQ,GAAGA,QAAQ;IAC1B,CAAC,CAAC,CAACC,IAAI,CAAC,qBAAK,GAAE,CAAC;EAClB;EAEA;;;EAGAC,SAAS,CAACC,KAAyC;IACjD,IAAI,IAAI,CAACH,QAAQ,EAAE;MACjB,IAAI,CAACA,QAAQ,CAACI,IAAI,CAACD,KAAK,CAAC;;EAE7B;EAEA;;;;;EAKAE,SAAS,CAACC,UAA6B,EAAEC,QAA6D;IACpG,IAAI,OAAOD,UAAU,KAAK,QAAQ,EAAE;MAClCA,UAAU,GAAG,CAACA,UAAU,CAAC;;IAE3B,OAAO,IAAI,CAACR,UAAU,CACnBG,IAAI,CACH,sBAAM,EAAEE,KAAyC,IAAI;MACnD,KAAK,MAAMK,SAAS,IAAIF,UAAU,EAAE;QAClC,IAAK,OAAOH,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAKK,SAAS,IAAM,OAAOL,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAACT,IAAI,KAAKc,SAAU,EAAE;UACjH,OAAO,IAAI;;;MAGf,OAAO,KAAK;IACd,CAAC,CAAC,CACH,CACAH,SAAS,CAACE,QAAQ,CAAC;EACxB;EAEA;;;EAGAE,OAAO,CAACC,UAAwB;IAC9BA,UAAU,CAACC,WAAW,EAAE;EAC1B;;AAlDFf;;mBAGaC,YAAY;AAAA;;SAAZA,YAAY;EAAAe,SAAZf,YAAY;EAAAgB,YAFX;AAAM","names":["EventWithContent","constructor","name","content","exports","EventManager","observable","rxjs_1","observer","pipe","broadcast","event","next","subscribe","eventNames","callback","eventName","destroy","subscriber","unsubscribe","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\D1347074\\Desktop\\projects 2\\nspayiiapp\\src\\main\\webapp\\app\\core\\util\\event-manager.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { Observable, Observer, Subscription } from 'rxjs';\r\nimport { filter, share } from 'rxjs/operators';\r\n\r\nexport class EventWithContent<T> {\r\n  constructor(public name: string, public content: T) {}\r\n}\r\n\r\n/**\r\n * An utility class to manage RX events\r\n */\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class EventManager {\r\n  observable: Observable<EventWithContent<unknown> | string>;\r\n  observer?: Observer<EventWithContent<unknown> | string>;\r\n\r\n  constructor() {\r\n    this.observable = new Observable((observer: Observer<EventWithContent<unknown> | string>) => {\r\n      this.observer = observer;\r\n    }).pipe(share());\r\n  }\r\n\r\n  /**\r\n   * Method to broadcast the event to observer\r\n   */\r\n  broadcast(event: EventWithContent<unknown> | string): void {\r\n    if (this.observer) {\r\n      this.observer.next(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Method to subscribe to an event with callback\r\n   * @param eventNames  Single event name or array of event names to what subscribe\r\n   * @param callback    Callback to run when the event occurs\r\n   */\r\n  subscribe(eventNames: string | string[], callback: (event: EventWithContent<unknown> | string) => void): Subscription {\r\n    if (typeof eventNames === 'string') {\r\n      eventNames = [eventNames];\r\n    }\r\n    return this.observable\r\n      .pipe(\r\n        filter((event: EventWithContent<unknown> | string) => {\r\n          for (const eventName of eventNames) {\r\n            if ((typeof event === 'string' && event === eventName) || (typeof event !== 'string' && event.name === eventName)) {\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        })\r\n      )\r\n      .subscribe(callback);\r\n  }\r\n\r\n  /**\r\n   * Method to unsubscribe the subscription\r\n   */\r\n  destroy(subscriber: Subscription): void {\r\n    subscriber.unsubscribe();\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}