{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DateValidator = void 0;\nconst tslib_1 = require(\"tslib\");\nconst moment_1 = tslib_1.__importDefault(require(\"moment\"));\nclass DateValidator {\n  static dateNotEquals(dateField1, dateField2) {\n    return c => {\n      const date1 = c.get(dateField1).value;\n      const date2 = c.get(dateField2).value;\n      if (date1 === date2) {\n        return {\n          invalidDatNotEquals: true\n        };\n      }\n      return null;\n    };\n  }\n  static dateLessThan(dateField1, dateField2) {\n    return c => {\n      const date1 = c.get(dateField1).value;\n      const date2 = c.get(dateField2).value;\n      if (date1 !== null && date2 !== null && date1 > date2) {\n        return {\n          invalidDateLessThan: true\n        };\n      }\n      return null;\n    };\n  }\n  static dateLessThanOrEquals(dateField1, dateField2) {\n    return c => {\n      const date1 = c.get(dateField1).value;\n      const date2 = c.get(dateField2).value;\n      if (date1 !== null && date2 !== null && date1 >= date2) {\n        return {\n          invalidDateLessThanOrEquals: true\n        };\n      }\n      return null;\n    };\n  }\n  static decimalPlace(amt1) {\n    return c => {\n      const amt = c.get(amt1).value;\n      if (amt != null) {\n        if (amt.split('.')[1].length !== 2) {\n          return {\n            decpoint: true\n          };\n        }\n      } else {\n        return null;\n      }\n      return null;\n    };\n  }\n  static isBeforeStartDate(startDateName, endDateName) {\n    return c => {\n      if (c.parent == null) {\n        return null;\n      }\n      const start = c.parent.value[startDateName];\n      let end = c.parent.value[endDateName];\n      end = c.value;\n      if (!(0, moment_1.default)(start, 'DD/MM/YYYY', true).isValid() || !(0, moment_1.default)(end, 'DD/MM/YYYY', true).isValid()) {\n        return null;\n      }\n      const mStartDt = (0, moment_1.default)(start, 'DD/MM/YYYY', true);\n      const mEndDt = (0, moment_1.default)(end, 'DD/MM/YYYY', true);\n      if (mEndDt.isSameOrAfter(mStartDt)) {\n        return null;\n      } else {\n        return {\n          'isBeforeStartDt': true\n        };\n      }\n    };\n  }\n  static dateEqual(dateField1, dateField2) {\n    return c => {\n      const date1 = c.get(dateField1).value;\n      const date2 = c.get(dateField2).value;\n      if (date1 === date2) {\n        return null;\n      }\n      return {\n        invalidDateEquals: true\n      };\n    };\n  }\n  static timeLessThan(Timefield1, Timefield2) {\n    return c => {\n      const time1 = c.get(Timefield1).value;\n      const time2 = c.get(Timefield2).value;\n      if (time1 !== null && time2 !== null && time1 >= time2) {\n        return {\n          invalidTimeLessThan: true\n        };\n      }\n      return null;\n    };\n  }\n  static dateRangeMoreThan(dateField1, dateField2, threshold) {\n    return c => {\n      const date1 = c.get(dateField1).value;\n      const date2 = c.get(dateField2).value;\n      const diffDays = (0, moment_1.default)(date2).diff((0, moment_1.default)(date1), 'days');\n      if (diffDays > threshold) {\n        return {\n          invalidDateRangeMoreThan: true\n        };\n      }\n      return null;\n    };\n  }\n  static isValidDate() {\n    return c => {\n      if (!(0, moment_1.default)(c.value).isValid()) {\n        return {\n          invalidDate: true\n        };\n      }\n      return null;\n    };\n  }\n}\nexports.DateValidator = DateValidator;","map":{"version":3,"mappings":"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","names":["DateValidator","dateNotEquals","dateField1","dateField2","c","date1","get","value","date2","invalidDatNotEquals","dateLessThan","invalidDateLessThan","dateLessThanOrEquals","invalidDateLessThanOrEquals","decimalPlace","amt1","amt","split","length","decpoint","isBeforeStartDate","startDateName","endDateName","parent","start","end","isValid","mStartDt","mEndDt","isSameOrAfter","dateEqual","invalidDateEquals","timeLessThan","Timefield1","Timefield2","time1","time2","invalidTimeLessThan","dateRangeMoreThan","threshold","diffDays","diff","invalidDateRangeMoreThan","isValidDate","invalidDate","exports"],"sourceRoot":"","sources":["C:\\Users\\D1347074\\Desktop\\projects 2\\nspayiiapp\\src\\main\\webapp\\app\\shared\\validator\\date-validator.directive.ts"],"sourcesContent":["import { ValidatorFn, AbstractControl, FormControl } from '@angular/forms';\r\nimport { NSPAppConstants } from 'app/shared/constants/nspapp.constants';\r\nimport moment from 'moment';\r\n\r\nexport class DateValidator {\r\n\r\n  static dateNotEquals(dateField1: string, dateField2: string): ValidatorFn {\r\n    return (c: AbstractControl): { [key: string]: boolean } | null => {\r\n      const date1 = c.get(dateField1).value;\r\n      const date2 = c.get(dateField2).value;\r\n      if (date1 === date2) {\r\n        return { invalidDatNotEquals: true };\r\n      }\r\n      return null;\r\n    };\r\n  }\r\n\r\n  static dateLessThan(dateField1: string, dateField2: string): ValidatorFn {\r\n    return (c: AbstractControl): { [key: string]: boolean } | null => {\r\n      const date1 = c.get(dateField1).value;\r\n      const date2 = c.get(dateField2).value;\r\n      if ((date1 !== null && date2 !== null) && date1 > date2) {\r\n        return { invalidDateLessThan: true };\r\n      }\r\n      return null;\r\n    };\r\n  }\r\n\r\n  static dateLessThanOrEquals(dateField1: string, dateField2: string): ValidatorFn {\r\n    return (c: AbstractControl): { [key: string]: boolean } | null => {\r\n      const date1 = c.get(dateField1).value;\r\n      const date2 = c.get(dateField2).value;\r\n      if ((date1 !== null && date2 !== null) && date1 >= date2) {\r\n        return { invalidDateLessThanOrEquals: true };\r\n      }\r\n      return null;\r\n    };\r\n  }\r\n\r\n  static decimalPlace(amt1: string): ValidatorFn {\r\n    return (c: AbstractControl): { [key: string]: boolean } | null => {\r\n      const amt = c.get(amt1).value;\r\n      if (amt != null) {\r\n        if (amt.split('.')[1].length !== 2) {\r\n          return { decpoint: true };\r\n        }\r\n      } else {\r\n        return null;\r\n      }\r\n      return null;\r\n    };\r\n  }\r\n\r\n  static isBeforeStartDate(startDateName: string, endDateName: string): ValidatorFn {\r\n    return (c: FormControl): { [key: string]: boolean } | null => {\r\n\r\n      if (c.parent == null) {\r\n        return null;\r\n      }\r\n      const start = c.parent.value[startDateName];\r\n      let end = c.parent.value[endDateName];\r\n      end = c.value;\r\n\r\n      if (!moment(start, 'DD/MM/YYYY', true).isValid() || !moment(end, 'DD/MM/YYYY', true).isValid()) {\r\n        return null;\r\n      }\r\n\r\n      const mStartDt = moment(start, 'DD/MM/YYYY', true);\r\n      const mEndDt = moment(end, 'DD/MM/YYYY', true);\r\n      if (mEndDt.isSameOrAfter(mStartDt)) {\r\n        return null;\r\n      } else {\r\n        return { 'isBeforeStartDt': true };\r\n      }\r\n    };\r\n  }\r\n\r\n  static dateEqual(dateField1: string, dateField2: string): ValidatorFn {\r\n    return (c: AbstractControl): { [key: string]: boolean } | null => {\r\n      const date1 = c.get(dateField1).value;\r\n      const date2 = c.get(dateField2).value;\r\n      if (date1 === date2) {\r\n        return null;\r\n      }\r\n      return { invalidDateEquals: true };\r\n    };\r\n  }\r\n\r\n  static timeLessThan(Timefield1: string, Timefield2: string): ValidatorFn {\r\n    return (c: AbstractControl): { [key: string]: boolean } | null => {\r\n      const time1 = c.get(Timefield1).value;\r\n      const time2 = c.get(Timefield2).value;\r\n      if ((time1 !== null && time2 !== null) && time1 >= time2) {\r\n        return { invalidTimeLessThan: true };\r\n      }\r\n      return null;\r\n    };\r\n  }\r\n\r\n  static dateRangeMoreThan(dateField1: string, dateField2: string, threshold: number): ValidatorFn {\r\n    return (c: AbstractControl): { [key: string]: boolean } | null => {\r\n      const date1 = c.get(dateField1).value;\r\n      const date2 = c.get(dateField2).value;\r\n      const diffDays = moment(date2).diff(moment(date1),'days')\r\n\r\n      if (diffDays> threshold) {\r\n        return { invalidDateRangeMoreThan: true };\r\n      }\r\n      return null;\r\n    };\r\n  }\r\n\r\n  static  isValidDate(): ValidatorFn {\r\n    return (c: AbstractControl) : { [key: string]: boolean } | null => {\r\n      if(!moment(c.value).isValid()) {\r\n        return { invalidDate: true };\r\n      }\r\n      return null;\r\n    };\r\n  }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}