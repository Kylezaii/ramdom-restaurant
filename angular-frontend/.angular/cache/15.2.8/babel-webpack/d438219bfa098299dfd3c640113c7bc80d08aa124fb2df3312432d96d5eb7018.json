{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AlertService = void 0;\nconst tslib_1 = require(\"tslib\");\nconst core_1 = require(\"@angular/core\");\nconst translation_config_1 = require(\"app/config/translation.config\");\nconst i0 = tslib_1.__importStar(require(\"@angular/core\"));\nconst i1 = tslib_1.__importStar(require(\"@angular/platform-browser\"));\nconst i2 = tslib_1.__importStar(require(\"@ngx-translate/core\"));\nclass AlertService {\n  constructor(sanitizer, ngZone, translateService) {\n    this.sanitizer = sanitizer;\n    this.ngZone = ngZone;\n    this.translateService = translateService;\n    this.timeout = 5000;\n    this.toast = false;\n    this.position = 'top right';\n    // unique id for each alert. Starts from 0.\n    this.alertId = 0;\n    this.alerts = [];\n  }\n  clear() {\n    this.alerts = [];\n  }\n  get() {\n    return this.alerts;\n  }\n  /**\r\n   * Adds alert to alerts array and returns added alert.\r\n   * @param alert      Alert to add. If `timeout`, `toast` or `position` is missing then applying default value.\r\n   *                   If `translateKey` is available then it's translation else `message` is used for showing.\r\n   * @param extAlerts  If missing then adding `alert` to `AlertService` internal array and alerts can be retrieved by `get()`.\r\n   *                   Else adding `alert` to `extAlerts`.\r\n   * @returns  Added alert\r\n   */\n  addAlert(alert, extAlerts) {\n    alert.id = this.alertId++;\n    if (alert.translationKey) {\n      const translatedMessage = this.translateService.instant(alert.translationKey, alert.translationParams);\n      // if translation key exists\n      if (translatedMessage !== `${translation_config_1.translationNotFoundMessage}[${alert.translationKey}]`) {\n        alert.message = translatedMessage;\n      } else if (!alert.message) {\n        alert.message = alert.translationKey;\n      }\n    }\n    alert.message = this.sanitizer.sanitize(core_1.SecurityContext.HTML, alert.message ?? '') ?? '';\n    alert.timeout = alert.timeout ?? this.timeout;\n    alert.toast = alert.toast ?? this.toast;\n    alert.position = alert.position ?? this.position;\n    alert.close = alertsArray => this.closeAlert(alert.id, alertsArray);\n    (extAlerts ?? this.alerts).push(alert);\n    if (alert.timeout > 0) {\n      // Workaround protractor waiting for setTimeout.\n      // Reference https://www.protractortest.org/#/timeouts\n      this.ngZone.runOutsideAngular(() => {\n        setTimeout(() => {\n          this.ngZone.run(() => {\n            this.closeAlert(alert.id, extAlerts ?? this.alerts);\n          });\n        }, alert.timeout);\n      });\n    }\n    return alert;\n  }\n  closeAlert(alertId, extAlerts) {\n    const alerts = extAlerts ?? this.alerts;\n    const alertIndex = alerts.map(alert => alert.id).indexOf(alertId);\n    // if found alert then remove\n    if (alertIndex >= 0) {\n      alerts.splice(alertIndex, 1);\n    }\n  }\n}\nexports.AlertService = AlertService;\nAlertService.ɵfac = function AlertService_Factory(t) {\n  return new (t || AlertService)(i0.ɵɵinject(i1.DomSanitizer), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i2.TranslateService));\n};\nAlertService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: AlertService,\n  factory: AlertService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":";;;;;;;AAAA;AAGA;;;;AAgBA,MAGaA,YAAY;EASvBC,YAAoBC,SAAuB,EAAUC,MAAc,EAAUC,gBAAkC;IAA3F,cAAS,GAATF,SAAS;IAAwB,WAAM,GAANC,MAAM;IAAkB,qBAAgB,GAAhBC,gBAAgB;IAR7F,YAAO,GAAG,IAAI;IACd,UAAK,GAAG,KAAK;IACb,aAAQ,GAAG,WAAW;IAEtB;IACQ,YAAO,GAAG,CAAC;IACX,WAAM,GAAY,EAAE;EAEsF;EAElHC,KAAK;IACH,IAAI,CAACC,MAAM,GAAG,EAAE;EAClB;EAEAC,GAAG;IACD,OAAO,IAAI,CAACD,MAAM;EACpB;EAEA;;;;;;;;EAQAE,QAAQ,CAACC,KAAY,EAAEC,SAAmB;IACxCD,KAAK,CAACE,EAAE,GAAG,IAAI,CAACC,OAAO,EAAE;IAEzB,IAAIH,KAAK,CAACI,cAAc,EAAE;MACxB,MAAMC,iBAAiB,GAAG,IAAI,CAACV,gBAAgB,CAACW,OAAO,CAACN,KAAK,CAACI,cAAc,EAAEJ,KAAK,CAACO,iBAAiB,CAAC;MACtG;MACA,IAAIF,iBAAiB,KAAK,GAAGG,+CAA0B,IAAIR,KAAK,CAACI,cAAc,GAAG,EAAE;QAClFJ,KAAK,CAACS,OAAO,GAAGJ,iBAAiB;OAClC,MAAM,IAAI,CAACL,KAAK,CAACS,OAAO,EAAE;QACzBT,KAAK,CAACS,OAAO,GAAGT,KAAK,CAACI,cAAc;;;IAIxCJ,KAAK,CAACS,OAAO,GAAG,IAAI,CAAChB,SAAS,CAACiB,QAAQ,CAACC,sBAAe,CAACC,IAAI,EAAEZ,KAAK,CAACS,OAAO,IAAI,EAAE,CAAC,IAAI,EAAE;IACxFT,KAAK,CAACa,OAAO,GAAGb,KAAK,CAACa,OAAO,IAAI,IAAI,CAACA,OAAO;IAC7Cb,KAAK,CAACc,KAAK,GAAGd,KAAK,CAACc,KAAK,IAAI,IAAI,CAACA,KAAK;IACvCd,KAAK,CAACe,QAAQ,GAAGf,KAAK,CAACe,QAAQ,IAAI,IAAI,CAACA,QAAQ;IAChDf,KAAK,CAACgB,KAAK,GAAIC,WAAoB,IAAK,IAAI,CAACC,UAAU,CAAClB,KAAK,CAACE,EAAE,EAAEe,WAAW,CAAC;IAE9E,CAAChB,SAAS,IAAI,IAAI,CAACJ,MAAM,EAAEsB,IAAI,CAACnB,KAAK,CAAC;IAEtC,IAAIA,KAAK,CAACa,OAAO,GAAG,CAAC,EAAE;MACrB;MACA;MACA,IAAI,CAACnB,MAAM,CAAC0B,iBAAiB,CAAC,MAAK;QACjCC,UAAU,CAAC,MAAK;UACd,IAAI,CAAC3B,MAAM,CAAC4B,GAAG,CAAC,MAAK;YACnB,IAAI,CAACJ,UAAU,CAAClB,KAAK,CAACE,EAAE,EAAED,SAAS,IAAI,IAAI,CAACJ,MAAM,CAAC;UACrD,CAAC,CAAC;QACJ,CAAC,EAAEG,KAAK,CAACa,OAAO,CAAC;MACnB,CAAC,CAAC;;IAGJ,OAAOb,KAAK;EACd;EAEQkB,UAAU,CAACf,OAAe,EAAEF,SAAmB;IACrD,MAAMJ,MAAM,GAAGI,SAAS,IAAI,IAAI,CAACJ,MAAM;IACvC,MAAM0B,UAAU,GAAG1B,MAAM,CAAC2B,GAAG,CAACxB,KAAK,IAAIA,KAAK,CAACE,EAAE,CAAC,CAACuB,OAAO,CAACtB,OAAO,CAAC;IACjE;IACA,IAAIoB,UAAU,IAAI,CAAC,EAAE;MACnB1B,MAAM,CAAC6B,MAAM,CAACH,UAAU,EAAE,CAAC,CAAC;;EAEhC;;AAzEFI;;mBAGapC,YAAY;AAAA;;SAAZA,YAAY;EAAAqC,SAAZrC,YAAY;EAAAsC,YAFX;AAAM","names":["AlertService","constructor","sanitizer","ngZone","translateService","clear","alerts","get","addAlert","alert","extAlerts","id","alertId","translationKey","translatedMessage","instant","translationParams","translation_config_1","message","sanitize","core_1","HTML","timeout","toast","position","close","alertsArray","closeAlert","push","runOutsideAngular","setTimeout","run","alertIndex","map","indexOf","splice","exports","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\D1347074\\Desktop\\projects 2\\nspayiiapp\\src\\main\\webapp\\app\\core\\util\\alert.service.ts"],"sourcesContent":["import { Injectable, SecurityContext, NgZone } from '@angular/core';\r\nimport { DomSanitizer } from '@angular/platform-browser';\r\nimport { TranslateService } from '@ngx-translate/core';\r\nimport { translationNotFoundMessage } from 'app/config/translation.config';\r\n\r\nexport type AlertType = 'success' | 'danger' | 'warning' | 'info';\r\n\r\nexport interface Alert {\r\n  id?: number;\r\n  type: AlertType;\r\n  message?: string;\r\n  translationKey?: string;\r\n  translationParams?: { [key: string]: unknown };\r\n  timeout?: number;\r\n  toast?: boolean;\r\n  position?: string;\r\n  close?: (alerts: Alert[]) => void;\r\n}\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class AlertService {\r\n  timeout = 5000;\r\n  toast = false;\r\n  position = 'top right';\r\n\r\n  // unique id for each alert. Starts from 0.\r\n  private alertId = 0;\r\n  private alerts: Alert[] = [];\r\n\r\n  constructor(private sanitizer: DomSanitizer, private ngZone: NgZone, private translateService: TranslateService) {}\r\n\r\n  clear(): void {\r\n    this.alerts = [];\r\n  }\r\n\r\n  get(): Alert[] {\r\n    return this.alerts;\r\n  }\r\n\r\n  /**\r\n   * Adds alert to alerts array and returns added alert.\r\n   * @param alert      Alert to add. If `timeout`, `toast` or `position` is missing then applying default value.\r\n   *                   If `translateKey` is available then it's translation else `message` is used for showing.\r\n   * @param extAlerts  If missing then adding `alert` to `AlertService` internal array and alerts can be retrieved by `get()`.\r\n   *                   Else adding `alert` to `extAlerts`.\r\n   * @returns  Added alert\r\n   */\r\n  addAlert(alert: Alert, extAlerts?: Alert[]): Alert {\r\n    alert.id = this.alertId++;\r\n\r\n    if (alert.translationKey) {\r\n      const translatedMessage = this.translateService.instant(alert.translationKey, alert.translationParams);\r\n      // if translation key exists\r\n      if (translatedMessage !== `${translationNotFoundMessage}[${alert.translationKey}]`) {\r\n        alert.message = translatedMessage;\r\n      } else if (!alert.message) {\r\n        alert.message = alert.translationKey;\r\n      }\r\n    }\r\n\r\n    alert.message = this.sanitizer.sanitize(SecurityContext.HTML, alert.message ?? '') ?? '';\r\n    alert.timeout = alert.timeout ?? this.timeout;\r\n    alert.toast = alert.toast ?? this.toast;\r\n    alert.position = alert.position ?? this.position;\r\n    alert.close = (alertsArray: Alert[]) => this.closeAlert(alert.id, alertsArray);\r\n\r\n    (extAlerts ?? this.alerts).push(alert);\r\n\r\n    if (alert.timeout > 0) {\r\n      // Workaround protractor waiting for setTimeout.\r\n      // Reference https://www.protractortest.org/#/timeouts\r\n      this.ngZone.runOutsideAngular(() => {\r\n        setTimeout(() => {\r\n          this.ngZone.run(() => {\r\n            this.closeAlert(alert.id, extAlerts ?? this.alerts);\r\n          });\r\n        }, alert.timeout);\r\n      });\r\n    }\r\n\r\n    return alert;\r\n  }\r\n\r\n  private closeAlert(alertId: number, extAlerts?: Alert[]): void {\r\n    const alerts = extAlerts ?? this.alerts;\r\n    const alertIndex = alerts.map(alert => alert.id).indexOf(alertId);\r\n    // if found alert then remove\r\n    if (alertIndex >= 0) {\r\n      alerts.splice(alertIndex, 1);\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}