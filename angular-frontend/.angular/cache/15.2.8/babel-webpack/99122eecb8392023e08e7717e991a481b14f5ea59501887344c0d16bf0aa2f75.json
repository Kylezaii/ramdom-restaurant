{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommonValidator = void 0;\nconst forms_1 = require(\"@angular/forms\");\nconst nric_validate_1 = require(\"../../ng-connect/nric/nric-validate\");\n/* Validate common fields */\nclass CommonValidator {\n  static nricValidator() {\n    return c => {\n      let isValid = false;\n      if (c.value) {\n        isValid = (0, nric_validate_1.validateNRIC)(c.value);\n        if (isValid) {\n          return {};\n        } else {\n          return {\n            nric: true\n          };\n        }\n      } else {\n        return {};\n      }\n    };\n  }\n  // Check prefix-numberOnly-suffix\n  static basicNricValidator() {\n    return control => {\n      if (control.value && control.value.length > 0) {\n        if (control.value.match(/^[stfgmSTFGM]\\d{7}[A-Za-z]$/)) {\n          return null;\n        } else {\n          return {\n            'invalidNric': true\n          };\n        }\n      }\n      return null;\n    };\n  }\n  static alphaNumericValidator() {\n    return control => {\n      if (control.value && control.value.length > 0) {\n        if (control.value.match(/^[a-zA-Z\\d]+$/)) {\n          return null;\n        } else {\n          return {\n            'invalidAlphanumeric': true\n          };\n        }\n      }\n      return null;\n    };\n  }\n  static lettersOnlyValidator() {\n    return control => {\n      if (control.value && control.value.length > 0) {\n        if (control.value.match(/^[a-zA-Z]+$/)) {\n          return null;\n        } else {\n          return {\n            'invalidLetters': true\n          };\n        }\n      }\n      return null;\n    };\n  }\n  static mustNotEqualValidator(field1, field2) {\n    return c => {\n      const field1Val = c.get(field1).value;\n      const field2Val = c.get(field2).value;\n      if (field1Val && field2Val && typeof field1Val === typeof field2Val && field1Val === field2Val) {\n        return {\n          'mustNotEqual': true\n        };\n      } else return null;\n    };\n  }\n  static invalidIsMoreThanValidator(field1, field2) {\n    return c => {\n      const field1Val = c.get(field1).value;\n      const field2Val = c.get(field2).value;\n      if (field1Val && field2Val && typeof field1Val === typeof field2Val && field1Val > field2Val) {\n        return {\n          'invalidIsMoreThan': true\n        };\n      } else return null;\n    };\n  }\n  static numbersOnlyValidator() {\n    return control => {\n      if (control.value && control.value.length > 0) {\n        if (control.value.match(/^[\\d]+$/)) {\n          return null;\n        } else {\n          return {\n            'invalidNumbers': true\n          };\n        }\n      }\n      return null;\n    };\n  }\n  static numberRangeValidator(min, max) {\n    return control => {\n      if (control.parent == null) {\n        return null;\n      }\n      if (control.value && control.value.length > 0) {\n        const controlValue = control.value;\n        const number = parseInt(String(controlValue), 10);\n        if (number >= min && number <= max) {\n          return null;\n        } else {\n          return {\n            'numberNotInRange': true\n          };\n        }\n      }\n      return null;\n    };\n  }\n  // //conditional required validator\n  // //if form control is not empty, then required applies\n  static conditionalRequired(predicate) {\n    return formControl => {\n      if (!formControl.parent) {\n        return null;\n      }\n      if (predicate()) {\n        return forms_1.Validators.required(formControl);\n      }\n      return null;\n    };\n  }\n  static notFoundInList(list) {\n    return c => {\n      const upperCaseList = list.map(x => {\n        return x.toUpperCase();\n      });\n      if (!upperCaseList.includes(c.value?.toUpperCase())) {\n        return {\n          notFoundInList: true\n        };\n      }\n      return null;\n    };\n  }\n}\nexports.CommonValidator = CommonValidator;","map":{"version":3,"mappings":"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","names":["CommonValidator","nricValidator","c","isValid","value","nric","basicNricValidator","control","length","match","alphaNumericValidator","lettersOnlyValidator","mustNotEqualValidator","field1","field2","field1Val","get","field2Val","invalidIsMoreThanValidator","numbersOnlyValidator","numberRangeValidator","min","max","parent","controlValue","number","parseInt","String","conditionalRequired","predicate","formControl","forms_1","required","notFoundInList","list","upperCaseList","map","x","toUpperCase","includes","exports"],"sourceRoot":"","sources":["C:\\Users\\D1347074\\Desktop\\projects 2\\nspayiiapp\\src\\main\\webapp\\app\\shared\\validator\\common-validator.directive.ts"],"sourcesContent":["import { ValidatorFn, FormControl, AbstractControl, Validators } from '@angular/forms';\r\nimport { NSPAppConstants } from 'app/shared/constants/nspapp.constants';\r\nimport moment from 'moment';\r\nimport { validateNRIC } from '../../ng-connect/nric/nric-validate';\r\n\r\nexport interface BooleanFn {\r\n    (): boolean;\r\n}\r\n/* Validate common fields */\r\nexport class CommonValidator {\r\n    \r\n    static nricValidator(): ValidatorFn {\r\n        return (c: AbstractControl) : { [key: string]: boolean } | null => {\r\n            let isValid = false;\r\n            \r\n            if (c.value) {\r\n                isValid = validateNRIC(c.value);\r\n                if (isValid) {\r\n                  return {};\r\n                } else {\r\n                  return { nric: true };\r\n                }\r\n            } else {\r\n            return {};\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check prefix-numberOnly-suffix\r\n    static basicNricValidator(): ValidatorFn {\r\n        return (control: FormControl): { [key: string]: boolean } | null => {\r\n            if (control.value && control.value.length > 0) {\r\n                if (control.value.match(/^[stfgmSTFGM]\\d{7}[A-Za-z]$/)) {\r\n                    return null;\r\n                } else {\r\n                    return { 'invalidNric': true };\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n    }\r\n\r\n    static alphaNumericValidator(): ValidatorFn {\r\n        return (control: FormControl): { [key: string]: boolean } | null => {\r\n            if (control.value && control.value.length > 0) {\r\n                if (control.value.match(/^[a-zA-Z\\d]+$/)) {\r\n                    return null;\r\n                } else {\r\n                    return { 'invalidAlphanumeric': true };\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n    }\r\n\r\n    static lettersOnlyValidator(): ValidatorFn {\r\n        return (control: FormControl): { [key: string]: boolean } | null => {\r\n            if (control.value && control.value.length > 0) {\r\n                if (control.value.match(/^[a-zA-Z]+$/)) {\r\n                    return null;\r\n                } else {\r\n                    return { 'invalidLetters': true };\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n    }\r\n\r\n    static mustNotEqualValidator(field1: string, field2: string): ValidatorFn {\r\n    return (c: AbstractControl): { [key: string]: boolean } | null => {\r\n        const field1Val = c.get(field1).value;\r\n        const field2Val = c.get(field2).value;\r\n        if(field1Val && field2Val && typeof(field1Val) === typeof(field2Val) && field1Val === field2Val){      \r\n            return {'mustNotEqual': true}\r\n        }else return null;\r\n        };\r\n    }\r\n\r\n    static invalidIsMoreThanValidator(field1: string, field2: string): ValidatorFn {\r\n    return (c: AbstractControl): { [key: string]: boolean } | null => {\r\n        const field1Val = c.get(field1).value;\r\n        const field2Val = c.get(field2).value;\r\n        if(field1Val && field2Val && typeof(field1Val) === typeof(field2Val) && field1Val > field2Val){      \r\n            return {'invalidIsMoreThan': true}\r\n        }else return null;\r\n        };\r\n    }\r\n\r\n    static numbersOnlyValidator(): ValidatorFn {\r\n        return (control: FormControl): { [key: string]: boolean } | null => {\r\n            if (control.value && control.value.length > 0) {\r\n                if (control.value.match(/^[\\d]+$/)) {\r\n                    return null;\r\n                } else {\r\n                    return { 'invalidNumbers': true };\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n    }\r\n\r\n    static numberRangeValidator(min: number, max: number): ValidatorFn {\r\n        return (control: FormControl): { [key: string]: boolean } | null => {\r\n            \r\n            if (control.parent == null) {\r\n                return null;\r\n            }\r\n            if (control.value && control.value.length > 0) {\r\n                const controlValue = control.value;\r\n                const number = parseInt(String(controlValue), 10);\r\n                if (number >= min && number <= max) {\r\n                    return null;\r\n                } else {\r\n                    return { 'numberNotInRange': true };\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n    }\r\n\r\n    // //conditional required validator\r\n    // //if form control is not empty, then required applies\r\n    static conditionalRequired(predicate: BooleanFn): ValidatorFn {\r\n        return ((formControl: AbstractControl) => {\r\n            if (!formControl.parent) {\r\n              return null;\r\n            }\r\n            if (predicate()) {\r\n              return Validators.required(formControl); \r\n            }\r\n            return null;\r\n          })\r\n    }\r\n\r\n    static notFoundInList(list: string[]): ValidatorFn {\r\n    \r\n        return (c: AbstractControl): { [key: string]: boolean } | null => {\r\n            const upperCaseList = list.map(x=>{\r\n                return x.toUpperCase();\r\n              })\r\n            if(!upperCaseList.includes(c.value?.toUpperCase())){\r\n              return { notFoundInList: true };\r\n            }\r\n        \r\n          return null;\r\n        };\r\n      }\r\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}