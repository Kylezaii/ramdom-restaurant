{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable } from '@angular/core';\nimport { FormArray, FormGroup } from '@angular/forms';\nimport { ɵhasKey, ɵgetFieldValue, ɵreverseDeepMerge, ɵclone } from '@ngx-formly/core';\nimport { tap } from 'rxjs/operators';\n\n// https://stackoverflow.com/a/27865285\nfunction decimalPlaces(a) {\n  if (!isFinite(a)) {\n    return 0;\n  }\n  let e = 1,\n    p = 0;\n  while (Math.round(a * e) / e !== a) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\nfunction isEmpty(v) {\n  return v === '' || v == null;\n}\nfunction isObject(v) {\n  return v != null && typeof v === 'object' && !Array.isArray(v);\n}\nfunction isInteger(value) {\n  return Number.isInteger ? Number.isInteger(value) : typeof value === 'number' && Math.floor(value) === value;\n}\nfunction isConst(schema) {\n  return typeof schema === 'object' && (schema.hasOwnProperty('const') || schema.enum && schema.enum.length === 1);\n}\nfunction totalMatchedFields(field) {\n  if (!field.fieldGroup) {\n    return ɵhasKey(field) && ɵgetFieldValue(field) !== undefined ? 1 : 0;\n  }\n  const total = field.fieldGroup.reduce((s, f) => totalMatchedFields(f) + s, 0);\n  if (total === 0 && ɵhasKey(field)) {\n    const value = ɵgetFieldValue(field);\n    if (value === null || value !== undefined && (field.fieldArray && Array.isArray(value) || !field.fieldArray && isObject(value))) {\n      return 1;\n    }\n  }\n  return total;\n}\nclass FormlyJsonschema {\n  toFieldConfig(schema, options) {\n    return this._toFieldConfig(schema, {\n      schema,\n      ...(options || {})\n    });\n  }\n  _toFieldConfig(schema, {\n    key,\n    ...options\n  }) {\n    schema = this.resolveSchema(schema, options);\n    const types = this.guessSchemaType(schema);\n    let field = {\n      type: types[0],\n      defaultValue: schema.default,\n      props: {\n        label: schema.title,\n        readonly: schema.readOnly,\n        description: schema.description\n      }\n    };\n    if (key != null) {\n      field.key = key;\n    }\n    if (!options.ignoreDefault && (schema.readOnly || options.readOnly)) {\n      field.props.disabled = true;\n      options = {\n        ...options,\n        readOnly: true\n      };\n    }\n    if (options.resetOnHide) {\n      field.resetOnHide = true;\n    }\n    if (key && options.strict) {\n      this.addValidator(field, 'type', (c, f) => {\n        const value = ɵgetFieldValue(f);\n        if (value != null) {\n          switch (field.type) {\n            case 'string':\n              {\n                return typeof value === 'string';\n              }\n            case 'integer':\n              {\n                return isInteger(value);\n              }\n            case 'number':\n              {\n                return typeof value === 'number';\n              }\n            case 'object':\n              {\n                return isObject(value);\n              }\n            case 'array':\n              {\n                return Array.isArray(value);\n              }\n          }\n        }\n        return true;\n      });\n    }\n    if (options.shareFormControl === false) {\n      field.shareFormControl = false;\n    }\n    if (options.ignoreDefault) {\n      delete field.defaultValue;\n    }\n    this.addValidator(field, 'type', {\n      schemaType: types,\n      expression: ({\n        value\n      }) => {\n        if (value === undefined) {\n          return true;\n        }\n        if (value === null && types.indexOf('null') !== -1) {\n          return true;\n        }\n        switch (types[0]) {\n          case 'null':\n            {\n              return typeof value === null;\n            }\n          case 'string':\n            {\n              return typeof value === 'string';\n            }\n          case 'integer':\n            {\n              return isInteger(value);\n            }\n          case 'number':\n            {\n              return typeof value === 'number';\n            }\n          case 'object':\n            {\n              return isObject(value);\n            }\n          case 'array':\n            {\n              return Array.isArray(value);\n            }\n        }\n        return true;\n      }\n    });\n    switch (field.type) {\n      case 'number':\n      case 'integer':\n        {\n          field.parsers = [v => isEmpty(v) ? undefined : Number(v)];\n          if (schema.hasOwnProperty('minimum')) {\n            field.props.min = schema.minimum;\n          }\n          if (schema.hasOwnProperty('maximum')) {\n            field.props.max = schema.maximum;\n          }\n          if (schema.hasOwnProperty('exclusiveMinimum')) {\n            field.props.exclusiveMinimum = schema.exclusiveMinimum;\n            this.addValidator(field, 'exclusiveMinimum', ({\n              value\n            }) => isEmpty(value) || value > schema.exclusiveMinimum);\n          }\n          if (schema.hasOwnProperty('exclusiveMaximum')) {\n            field.props.exclusiveMaximum = schema.exclusiveMaximum;\n            this.addValidator(field, 'exclusiveMaximum', ({\n              value\n            }) => isEmpty(value) || value < schema.exclusiveMaximum);\n          }\n          if (schema.hasOwnProperty('multipleOf')) {\n            field.props.step = schema.multipleOf;\n            this.addValidator(field, 'multipleOf', ({\n              value\n            }) => {\n              if (isEmpty(value) || typeof value !== 'number' || value === 0 || schema.multipleOf <= 0) {\n                return true;\n              }\n              // https://github.com/ajv-validator/ajv/issues/652#issue-283610859\n              const multiplier = Math.pow(10, decimalPlaces(schema.multipleOf));\n              return Math.round(value * multiplier) % Math.round(schema.multipleOf * multiplier) === 0;\n            });\n          }\n          break;\n        }\n      case 'string':\n        {\n          field.parsers = [v => {\n            if (types.indexOf('null') !== -1) {\n              v = isEmpty(v) ? null : v;\n            } else if (!field.props.required) {\n              v = v === '' ? undefined : v;\n            }\n            return v;\n          }];\n          ['minLength', 'maxLength', 'pattern'].forEach(prop => {\n            if (schema.hasOwnProperty(prop)) {\n              field.props[prop] = schema[prop];\n            }\n          });\n          break;\n        }\n      case 'object':\n        {\n          if (!field.fieldGroup) {\n            field.fieldGroup = [];\n          }\n          const {\n            propDeps,\n            schemaDeps\n          } = this.resolveDependencies(schema);\n          Object.keys(schema.properties || {}).forEach(property => {\n            const isRequired = Array.isArray(schema.required) && schema.required.indexOf(property) !== -1;\n            const f = this._toFieldConfig(schema.properties[property], {\n              ...options,\n              key: property,\n              isOptional: options.isOptional || !isRequired\n            });\n            field.fieldGroup.push(f);\n            if (isRequired || propDeps[property]) {\n              f.expressions = {\n                ...(f.expressions || {}),\n                'props.required': f => {\n                  let parent = f.parent;\n                  const model = f.fieldGroup && f.key != null ? parent.model : f.model;\n                  while (parent.key == null && parent.parent) {\n                    parent = parent.parent;\n                  }\n                  const required = parent && parent.props ? parent.props.required : false;\n                  if (!model && !required) {\n                    return false;\n                  }\n                  if (Array.isArray(schema.required) && schema.required.indexOf(property) !== -1) {\n                    return true;\n                  }\n                  return propDeps[property] && f.model && propDeps[property].some(k => !isEmpty(f.model[k]));\n                }\n              };\n            }\n            if (schemaDeps[property]) {\n              const getConstValue = s => {\n                return s.hasOwnProperty('const') ? s.const : s.enum[0];\n              };\n              const oneOfSchema = schemaDeps[property].oneOf;\n              if (oneOfSchema && oneOfSchema.every(o => o.properties && o.properties[property] && isConst(o.properties[property]))) {\n                oneOfSchema.forEach(oneOfSchemaItem => {\n                  const {\n                    [property]: constSchema,\n                    ...properties\n                  } = oneOfSchemaItem.properties;\n                  field.fieldGroup.push({\n                    ...this._toFieldConfig({\n                      ...oneOfSchemaItem,\n                      properties\n                    }, {\n                      ...options,\n                      resetOnHide: true\n                    }),\n                    expressions: {\n                      hide: f => !f.model || getConstValue(constSchema) !== f.model[property]\n                    }\n                  });\n                });\n              } else {\n                field.fieldGroup.push({\n                  ...this._toFieldConfig(schemaDeps[property], options),\n                  expressions: {\n                    hide: f => !f.model || isEmpty(f.model[property])\n                  }\n                });\n              }\n            }\n          });\n          if (schema.oneOf) {\n            field.fieldGroup.push(this.resolveMultiSchema('oneOf', schema.oneOf, {\n              ...options,\n              shareFormControl: false\n            }));\n          }\n          if (schema.anyOf) {\n            field.fieldGroup.push(this.resolveMultiSchema('anyOf', schema.anyOf, options));\n          }\n          break;\n        }\n      case 'array':\n        {\n          if (schema.hasOwnProperty('minItems')) {\n            field.props.minItems = schema.minItems;\n            this.addValidator(field, 'minItems', (c, f) => {\n              const value = ɵgetFieldValue(f);\n              return isEmpty(value) || value.length >= schema.minItems;\n            });\n            if (!options.isOptional && schema.minItems > 0 && field.defaultValue === undefined) {\n              field.defaultValue = Array.from(new Array(schema.minItems));\n            }\n          }\n          if (schema.hasOwnProperty('maxItems')) {\n            field.props.maxItems = schema.maxItems;\n            this.addValidator(field, 'maxItems', (c, f) => {\n              const value = ɵgetFieldValue(f);\n              return isEmpty(value) || value.length <= schema.maxItems;\n            });\n          }\n          if (schema.hasOwnProperty('uniqueItems')) {\n            field.props.uniqueItems = schema.uniqueItems;\n            this.addValidator(field, 'uniqueItems', (c, f) => {\n              const value = ɵgetFieldValue(f);\n              if (isEmpty(value) || !schema.uniqueItems) {\n                return true;\n              }\n              const uniqueItems = Array.from(new Set(value.map(v => JSON.stringify(v))));\n              return uniqueItems.length === value.length;\n            });\n          }\n          // resolve items schema needed for isEnum check\n          if (schema.items && !Array.isArray(schema.items)) {\n            schema.items = this.resolveSchema(schema.items, options);\n          }\n          // TODO: remove isEnum check once adding an option to skip extension\n          if (!this.isEnum(schema)) {\n            field.fieldArray = root => {\n              if (!Array.isArray(schema.items)) {\n                // When items is a single schema, the additionalItems keyword is meaningless, and it should not be used.\n                const f = schema.items ? this._toFieldConfig(schema.items, options) : {};\n                if (f.props) {\n                  f.props.required = true;\n                }\n                return f;\n              }\n              const length = root.fieldGroup ? root.fieldGroup.length : 0;\n              const itemSchema = schema.items[length] ? schema.items[length] : schema.additionalItems;\n              const f = itemSchema ? this._toFieldConfig(itemSchema, options) : {};\n              if (f.props) {\n                f.props.required = true;\n              }\n              if (schema.items[length]) {\n                f.props.removable = false;\n              }\n              return f;\n            };\n          }\n          break;\n        }\n    }\n    if (schema.hasOwnProperty('const')) {\n      field.props.const = schema.const;\n      this.addValidator(field, 'const', ({\n        value\n      }) => value === schema.const);\n      if (!field.type) {\n        field.defaultValue = schema.const;\n      }\n    }\n    if (this.isEnum(schema)) {\n      field.props.multiple = field.type === 'array';\n      field.type = 'enum';\n      field.props.options = this.toEnumOptions(schema);\n    }\n    if (schema.oneOf && !field.type) {\n      delete field.key;\n      field.fieldGroup = [this.resolveMultiSchema('oneOf', schema.oneOf, {\n        ...options,\n        key,\n        shareFormControl: false\n      })];\n    }\n    if (schema.oneOf && !field.type) {\n      delete field.key;\n      field.fieldGroup = [this.resolveMultiSchema('oneOf', schema.oneOf, {\n        ...options,\n        key,\n        shareFormControl: false\n      })];\n    }\n    // map in possible formlyConfig options from the widget property\n    if (schema.widget?.formlyConfig) {\n      field = this.mergeFields(field, schema.widget.formlyConfig);\n    }\n    field.templateOptions = field.props;\n    // if there is a map function passed in, use it to allow the user to\n    // further customize how fields are being mapped\n    return options.map ? options.map(field, schema) : field;\n  }\n  resolveSchema(schema, options) {\n    if (schema && schema.$ref) {\n      schema = this.resolveDefinition(schema, options);\n    }\n    if (schema && schema.allOf) {\n      schema = this.resolveAllOf(schema, options);\n    }\n    return schema;\n  }\n  resolveAllOf({\n    allOf,\n    ...baseSchema\n  }, options) {\n    if (!allOf.length) {\n      throw Error(`allOf array can not be empty ${allOf}.`);\n    }\n    return allOf.reduce((base, schema) => {\n      schema = this.resolveSchema(schema, options);\n      if (base.required && schema.required) {\n        base.required = [...base.required, ...schema.required];\n      }\n      if (schema.uniqueItems) {\n        base.uniqueItems = schema.uniqueItems;\n      }\n      // resolve to min value\n      ['maxLength', 'maximum', 'exclusiveMaximum', 'maxItems', 'maxProperties'].forEach(prop => {\n        if (!isEmpty(base[prop]) && !isEmpty(schema[prop])) {\n          base[prop] = base[prop] < schema[prop] ? base[prop] : schema[prop];\n        }\n      });\n      // resolve to max value\n      ['minLength', 'minimum', 'exclusiveMinimum', 'minItems', 'minProperties'].forEach(prop => {\n        if (!isEmpty(base[prop]) && !isEmpty(schema[prop])) {\n          base[prop] = base[prop] > schema[prop] ? base[prop] : schema[prop];\n        }\n      });\n      return ɵreverseDeepMerge(base, schema);\n    }, baseSchema);\n  }\n  resolveMultiSchema(mode, schemas, options) {\n    return {\n      type: 'multischema',\n      fieldGroup: [{\n        type: 'enum',\n        defaultValue: -1,\n        props: {\n          multiple: mode === 'anyOf',\n          options: schemas.map((s, i) => ({\n            label: s.title,\n            value: i,\n            disabled: s.readOnly\n          }))\n        },\n        hooks: {\n          onInit: f => f.formControl.valueChanges.pipe(tap(() => f.options.detectChanges(f.parent)))\n        }\n      }, {\n        fieldGroup: schemas.map((s, i) => ({\n          ...this._toFieldConfig(s, {\n            ...options,\n            resetOnHide: true\n          }),\n          expressions: {\n            hide: (f, forceUpdate) => {\n              const control = f.parent.parent.fieldGroup[0].formControl;\n              if (control.value === -1 || forceUpdate) {\n                let value = f.parent.fieldGroup.map((f, i) => [f, i, this.isFieldValid(f, i, schemas, options)]).sort(([f1,, f1Valid], [f2,, f2Valid]) => {\n                  if (f1Valid !== f2Valid) {\n                    return f2Valid ? 1 : -1;\n                  }\n                  const matchedFields1 = totalMatchedFields(f1);\n                  const matchedFields2 = totalMatchedFields(f2);\n                  if (matchedFields1 === matchedFields2) {\n                    if (f1.props.disabled === f2.props.disabled) {\n                      return 0;\n                    }\n                    return matchedFields2 > matchedFields1 ? 1 : -1;\n                  }\n                  return matchedFields2 > matchedFields1 ? 1 : -1;\n                }).map(([, i]) => i);\n                if (mode === 'anyOf') {\n                  const definedValue = value.filter(i => totalMatchedFields(f.parent.fieldGroup[i]));\n                  value = definedValue.length > 0 ? definedValue : [value[0] || 0];\n                }\n                value = value.length > 0 ? value : [0];\n                control.setValue(mode === 'anyOf' ? value : value[0]);\n              }\n              return Array.isArray(control.value) ? control.value.indexOf(i) === -1 : control.value !== i;\n            }\n          }\n        }))\n      }]\n    };\n  }\n  resolveDefinition(schema, options) {\n    const [uri, pointer] = schema.$ref.split('#/');\n    if (uri) {\n      throw Error(`Remote schemas for ${schema.$ref} not supported yet.`);\n    }\n    const definition = !pointer ? null : pointer.split('/').reduce((def, path) => def?.hasOwnProperty(path) ? def[path] : null, options.schema);\n    if (!definition) {\n      throw Error(`Cannot find a definition for ${schema.$ref}.`);\n    }\n    if (definition.$ref) {\n      return this.resolveDefinition(definition, options);\n    }\n    return {\n      ...definition,\n      ...['title', 'description', 'default', 'widget'].reduce((annotation, p) => {\n        if (schema.hasOwnProperty(p)) {\n          annotation[p] = schema[p];\n        }\n        return annotation;\n      }, {})\n    };\n  }\n  resolveDependencies(schema) {\n    const propDeps = {};\n    const schemaDeps = {};\n    Object.keys(schema.dependencies || {}).forEach(prop => {\n      const dependency = schema.dependencies[prop];\n      if (Array.isArray(dependency)) {\n        // Property dependencies\n        dependency.forEach(dep => {\n          if (!propDeps[dep]) {\n            propDeps[dep] = [prop];\n          } else {\n            propDeps[dep].push(prop);\n          }\n        });\n      } else {\n        // schema dependencies\n        schemaDeps[prop] = dependency;\n      }\n    });\n    return {\n      propDeps,\n      schemaDeps\n    };\n  }\n  guessSchemaType(schema) {\n    const type = schema?.type;\n    if (!type && schema?.properties) {\n      return ['object'];\n    }\n    if (Array.isArray(type)) {\n      if (type.length === 1) {\n        return type;\n      }\n      if (type.length === 2 && type.indexOf('null') !== -1) {\n        return type.sort(t1 => t1 == 'null' ? 1 : -1);\n      }\n      return type;\n    }\n    return type ? [type] : [];\n  }\n  addValidator(field, name, validator) {\n    field.validators = field.validators || {};\n    field.validators[name] = validator;\n  }\n  isEnum(schema) {\n    return !!schema.enum || schema.anyOf && schema.anyOf.every(isConst) || schema.oneOf && schema.oneOf.every(isConst) || schema.uniqueItems && schema.items && !Array.isArray(schema.items) && this.isEnum(schema.items);\n  }\n  toEnumOptions(schema) {\n    if (schema.enum) {\n      return schema.enum.map(value => ({\n        value,\n        label: value\n      }));\n    }\n    const toEnum = s => {\n      const value = s.hasOwnProperty('const') ? s.const : s.enum[0];\n      const option = {\n        value,\n        label: s.title || value\n      };\n      if (s.readOnly) {\n        option.disabled = true;\n      }\n      return option;\n    };\n    if (schema.anyOf) {\n      return schema.anyOf.map(toEnum);\n    }\n    if (schema.oneOf) {\n      return schema.oneOf.map(toEnum);\n    }\n    return this.toEnumOptions(schema.items);\n  }\n  isFieldValid(root, i, schemas, options) {\n    if (!root._schemasFields) {\n      Object.defineProperty(root, '_schemasFields', {\n        enumerable: false,\n        writable: true,\n        configurable: true\n      });\n      root._schemasFields = {};\n    }\n    let field = root._schemasFields[i];\n    const model = root.model ? ɵclone(root.model) : root.fieldArray ? [] : {};\n    if (!field) {\n      field = root._schemasFields[i] = root.options.build({\n        form: Array.isArray(model) ? new FormArray([]) : new FormGroup({}),\n        fieldGroup: [this._toFieldConfig(schemas[i], {\n          ...options,\n          resetOnHide: true,\n          ignoreDefault: true,\n          map: null,\n          strict: true\n        })],\n        model,\n        options: {}\n      });\n    } else {\n      field.model = model;\n      root.options.build(field);\n    }\n    return field.form.valid;\n  }\n  mergeFields(f1, f2) {\n    for (let prop in f2) {\n      const f1Prop = prop === 'templateOptions' ? 'props' : prop;\n      if (isObject(f1[f1Prop]) && isObject(f2[prop])) {\n        f1[f1Prop] = this.mergeFields(f1[f1Prop], f2[prop]);\n      } else if (f2[prop] != null) {\n        f1[f1Prop] = f2[prop];\n      }\n    }\n    return f1;\n  }\n}\nFormlyJsonschema.ɵfac = function FormlyJsonschema_Factory(t) {\n  return new (t || FormlyJsonschema)();\n};\nFormlyJsonschema.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FormlyJsonschema,\n  factory: FormlyJsonschema.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FormlyJsonschema, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { FormlyJsonschema };","map":{"version":3,"names":["i0","Injectable","FormArray","FormGroup","ɵhasKey","ɵgetFieldValue","ɵreverseDeepMerge","ɵclone","tap","decimalPlaces","a","isFinite","e","p","Math","round","isEmpty","v","isObject","Array","isArray","isInteger","value","Number","floor","isConst","schema","hasOwnProperty","enum","length","totalMatchedFields","field","fieldGroup","undefined","total","reduce","s","f","fieldArray","FormlyJsonschema","toFieldConfig","options","_toFieldConfig","key","resolveSchema","types","guessSchemaType","type","defaultValue","default","props","label","title","readonly","readOnly","description","ignoreDefault","disabled","resetOnHide","strict","addValidator","c","shareFormControl","schemaType","expression","indexOf","parsers","min","minimum","max","maximum","exclusiveMinimum","exclusiveMaximum","step","multipleOf","multiplier","pow","required","forEach","prop","propDeps","schemaDeps","resolveDependencies","Object","keys","properties","property","isRequired","isOptional","push","expressions","parent","model","some","k","getConstValue","const","oneOfSchema","oneOf","every","o","oneOfSchemaItem","constSchema","hide","resolveMultiSchema","anyOf","minItems","from","maxItems","uniqueItems","Set","map","JSON","stringify","items","isEnum","root","itemSchema","additionalItems","removable","multiple","toEnumOptions","widget","formlyConfig","mergeFields","templateOptions","$ref","resolveDefinition","allOf","resolveAllOf","baseSchema","Error","base","mode","schemas","i","hooks","onInit","formControl","valueChanges","pipe","detectChanges","forceUpdate","control","isFieldValid","sort","f1","f1Valid","f2","f2Valid","matchedFields1","matchedFields2","definedValue","filter","setValue","uri","pointer","split","definition","def","path","annotation","dependencies","dependency","dep","t1","name","validator","validators","toEnum","option","_schemasFields","defineProperty","enumerable","writable","configurable","build","form","valid","f1Prop","ɵfac","ɵprov","args","providedIn"],"sources":["C:/Users/D1347074/Desktop/projects 2/nspayiiapp/node_modules/@ngx-formly/core/fesm2020/ngx-formly-core-json-schema.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable } from '@angular/core';\nimport { FormArray, FormGroup } from '@angular/forms';\nimport { ɵhasKey, ɵgetFieldValue, ɵreverseDeepMerge, ɵclone } from '@ngx-formly/core';\nimport { tap } from 'rxjs/operators';\n\n// https://stackoverflow.com/a/27865285\nfunction decimalPlaces(a) {\n    if (!isFinite(a)) {\n        return 0;\n    }\n    let e = 1, p = 0;\n    while (Math.round(a * e) / e !== a) {\n        e *= 10;\n        p++;\n    }\n    return p;\n}\nfunction isEmpty(v) {\n    return v === '' || v == null;\n}\nfunction isObject(v) {\n    return v != null && typeof v === 'object' && !Array.isArray(v);\n}\nfunction isInteger(value) {\n    return Number.isInteger ? Number.isInteger(value) : typeof value === 'number' && Math.floor(value) === value;\n}\nfunction isConst(schema) {\n    return typeof schema === 'object' && (schema.hasOwnProperty('const') || (schema.enum && schema.enum.length === 1));\n}\nfunction totalMatchedFields(field) {\n    if (!field.fieldGroup) {\n        return ɵhasKey(field) && ɵgetFieldValue(field) !== undefined ? 1 : 0;\n    }\n    const total = field.fieldGroup.reduce((s, f) => totalMatchedFields(f) + s, 0);\n    if (total === 0 && ɵhasKey(field)) {\n        const value = ɵgetFieldValue(field);\n        if (value === null ||\n            (value !== undefined && ((field.fieldArray && Array.isArray(value)) || (!field.fieldArray && isObject(value))))) {\n            return 1;\n        }\n    }\n    return total;\n}\nclass FormlyJsonschema {\n    toFieldConfig(schema, options) {\n        return this._toFieldConfig(schema, { schema, ...(options || {}) });\n    }\n    _toFieldConfig(schema, { key, ...options }) {\n        schema = this.resolveSchema(schema, options);\n        const types = this.guessSchemaType(schema);\n        let field = {\n            type: types[0],\n            defaultValue: schema.default,\n            props: {\n                label: schema.title,\n                readonly: schema.readOnly,\n                description: schema.description,\n            },\n        };\n        if (key != null) {\n            field.key = key;\n        }\n        if (!options.ignoreDefault && (schema.readOnly || options.readOnly)) {\n            field.props.disabled = true;\n            options = { ...options, readOnly: true };\n        }\n        if (options.resetOnHide) {\n            field.resetOnHide = true;\n        }\n        if (key && options.strict) {\n            this.addValidator(field, 'type', (c, f) => {\n                const value = ɵgetFieldValue(f);\n                if (value != null) {\n                    switch (field.type) {\n                        case 'string': {\n                            return typeof value === 'string';\n                        }\n                        case 'integer': {\n                            return isInteger(value);\n                        }\n                        case 'number': {\n                            return typeof value === 'number';\n                        }\n                        case 'object': {\n                            return isObject(value);\n                        }\n                        case 'array': {\n                            return Array.isArray(value);\n                        }\n                    }\n                }\n                return true;\n            });\n        }\n        if (options.shareFormControl === false) {\n            field.shareFormControl = false;\n        }\n        if (options.ignoreDefault) {\n            delete field.defaultValue;\n        }\n        this.addValidator(field, 'type', {\n            schemaType: types,\n            expression: ({ value }) => {\n                if (value === undefined) {\n                    return true;\n                }\n                if (value === null && types.indexOf('null') !== -1) {\n                    return true;\n                }\n                switch (types[0]) {\n                    case 'null': {\n                        return typeof value === null;\n                    }\n                    case 'string': {\n                        return typeof value === 'string';\n                    }\n                    case 'integer': {\n                        return isInteger(value);\n                    }\n                    case 'number': {\n                        return typeof value === 'number';\n                    }\n                    case 'object': {\n                        return isObject(value);\n                    }\n                    case 'array': {\n                        return Array.isArray(value);\n                    }\n                }\n                return true;\n            },\n        });\n        switch (field.type) {\n            case 'number':\n            case 'integer': {\n                field.parsers = [(v) => (isEmpty(v) ? undefined : Number(v))];\n                if (schema.hasOwnProperty('minimum')) {\n                    field.props.min = schema.minimum;\n                }\n                if (schema.hasOwnProperty('maximum')) {\n                    field.props.max = schema.maximum;\n                }\n                if (schema.hasOwnProperty('exclusiveMinimum')) {\n                    field.props.exclusiveMinimum = schema.exclusiveMinimum;\n                    this.addValidator(field, 'exclusiveMinimum', ({ value }) => isEmpty(value) || value > schema.exclusiveMinimum);\n                }\n                if (schema.hasOwnProperty('exclusiveMaximum')) {\n                    field.props.exclusiveMaximum = schema.exclusiveMaximum;\n                    this.addValidator(field, 'exclusiveMaximum', ({ value }) => isEmpty(value) || value < schema.exclusiveMaximum);\n                }\n                if (schema.hasOwnProperty('multipleOf')) {\n                    field.props.step = schema.multipleOf;\n                    this.addValidator(field, 'multipleOf', ({ value }) => {\n                        if (isEmpty(value) || typeof value !== 'number' || value === 0 || schema.multipleOf <= 0) {\n                            return true;\n                        }\n                        // https://github.com/ajv-validator/ajv/issues/652#issue-283610859\n                        const multiplier = Math.pow(10, decimalPlaces(schema.multipleOf));\n                        return Math.round(value * multiplier) % Math.round(schema.multipleOf * multiplier) === 0;\n                    });\n                }\n                break;\n            }\n            case 'string': {\n                field.parsers = [\n                    (v) => {\n                        if (types.indexOf('null') !== -1) {\n                            v = isEmpty(v) ? null : v;\n                        }\n                        else if (!field.props.required) {\n                            v = v === '' ? undefined : v;\n                        }\n                        return v;\n                    },\n                ];\n                ['minLength', 'maxLength', 'pattern'].forEach((prop) => {\n                    if (schema.hasOwnProperty(prop)) {\n                        field.props[prop] = schema[prop];\n                    }\n                });\n                break;\n            }\n            case 'object': {\n                if (!field.fieldGroup) {\n                    field.fieldGroup = [];\n                }\n                const { propDeps, schemaDeps } = this.resolveDependencies(schema);\n                Object.keys(schema.properties || {}).forEach((property) => {\n                    const isRequired = Array.isArray(schema.required) && schema.required.indexOf(property) !== -1;\n                    const f = this._toFieldConfig(schema.properties[property], {\n                        ...options,\n                        key: property,\n                        isOptional: options.isOptional || !isRequired,\n                    });\n                    field.fieldGroup.push(f);\n                    if (isRequired || propDeps[property]) {\n                        f.expressions = {\n                            ...(f.expressions || {}),\n                            'props.required': (f) => {\n                                let parent = f.parent;\n                                const model = f.fieldGroup && f.key != null ? parent.model : f.model;\n                                while (parent.key == null && parent.parent) {\n                                    parent = parent.parent;\n                                }\n                                const required = parent && parent.props ? parent.props.required : false;\n                                if (!model && !required) {\n                                    return false;\n                                }\n                                if (Array.isArray(schema.required) && schema.required.indexOf(property) !== -1) {\n                                    return true;\n                                }\n                                return propDeps[property] && f.model && propDeps[property].some((k) => !isEmpty(f.model[k]));\n                            },\n                        };\n                    }\n                    if (schemaDeps[property]) {\n                        const getConstValue = (s) => {\n                            return s.hasOwnProperty('const') ? s.const : s.enum[0];\n                        };\n                        const oneOfSchema = schemaDeps[property].oneOf;\n                        if (oneOfSchema &&\n                            oneOfSchema.every((o) => o.properties && o.properties[property] && isConst(o.properties[property]))) {\n                            oneOfSchema.forEach((oneOfSchemaItem) => {\n                                const { [property]: constSchema, ...properties } = oneOfSchemaItem.properties;\n                                field.fieldGroup.push({\n                                    ...this._toFieldConfig({ ...oneOfSchemaItem, properties }, { ...options, resetOnHide: true }),\n                                    expressions: {\n                                        hide: (f) => !f.model || getConstValue(constSchema) !== f.model[property],\n                                    },\n                                });\n                            });\n                        }\n                        else {\n                            field.fieldGroup.push({\n                                ...this._toFieldConfig(schemaDeps[property], options),\n                                expressions: {\n                                    hide: (f) => !f.model || isEmpty(f.model[property]),\n                                },\n                            });\n                        }\n                    }\n                });\n                if (schema.oneOf) {\n                    field.fieldGroup.push(this.resolveMultiSchema('oneOf', schema.oneOf, { ...options, shareFormControl: false }));\n                }\n                if (schema.anyOf) {\n                    field.fieldGroup.push(this.resolveMultiSchema('anyOf', schema.anyOf, options));\n                }\n                break;\n            }\n            case 'array': {\n                if (schema.hasOwnProperty('minItems')) {\n                    field.props.minItems = schema.minItems;\n                    this.addValidator(field, 'minItems', (c, f) => {\n                        const value = ɵgetFieldValue(f);\n                        return isEmpty(value) || value.length >= schema.minItems;\n                    });\n                    if (!options.isOptional && schema.minItems > 0 && field.defaultValue === undefined) {\n                        field.defaultValue = Array.from(new Array(schema.minItems));\n                    }\n                }\n                if (schema.hasOwnProperty('maxItems')) {\n                    field.props.maxItems = schema.maxItems;\n                    this.addValidator(field, 'maxItems', (c, f) => {\n                        const value = ɵgetFieldValue(f);\n                        return isEmpty(value) || value.length <= schema.maxItems;\n                    });\n                }\n                if (schema.hasOwnProperty('uniqueItems')) {\n                    field.props.uniqueItems = schema.uniqueItems;\n                    this.addValidator(field, 'uniqueItems', (c, f) => {\n                        const value = ɵgetFieldValue(f);\n                        if (isEmpty(value) || !schema.uniqueItems) {\n                            return true;\n                        }\n                        const uniqueItems = Array.from(new Set(value.map((v) => JSON.stringify(v))));\n                        return uniqueItems.length === value.length;\n                    });\n                }\n                // resolve items schema needed for isEnum check\n                if (schema.items && !Array.isArray(schema.items)) {\n                    schema.items = this.resolveSchema(schema.items, options);\n                }\n                // TODO: remove isEnum check once adding an option to skip extension\n                if (!this.isEnum(schema)) {\n                    field.fieldArray = (root) => {\n                        if (!Array.isArray(schema.items)) {\n                            // When items is a single schema, the additionalItems keyword is meaningless, and it should not be used.\n                            const f = schema.items ? this._toFieldConfig(schema.items, options) : {};\n                            if (f.props) {\n                                f.props.required = true;\n                            }\n                            return f;\n                        }\n                        const length = root.fieldGroup ? root.fieldGroup.length : 0;\n                        const itemSchema = schema.items[length] ? schema.items[length] : schema.additionalItems;\n                        const f = itemSchema ? this._toFieldConfig(itemSchema, options) : {};\n                        if (f.props) {\n                            f.props.required = true;\n                        }\n                        if (schema.items[length]) {\n                            f.props.removable = false;\n                        }\n                        return f;\n                    };\n                }\n                break;\n            }\n        }\n        if (schema.hasOwnProperty('const')) {\n            field.props.const = schema.const;\n            this.addValidator(field, 'const', ({ value }) => value === schema.const);\n            if (!field.type) {\n                field.defaultValue = schema.const;\n            }\n        }\n        if (this.isEnum(schema)) {\n            field.props.multiple = field.type === 'array';\n            field.type = 'enum';\n            field.props.options = this.toEnumOptions(schema);\n        }\n        if (schema.oneOf && !field.type) {\n            delete field.key;\n            field.fieldGroup = [\n                this.resolveMultiSchema('oneOf', schema.oneOf, { ...options, key, shareFormControl: false }),\n            ];\n        }\n        if (schema.oneOf && !field.type) {\n            delete field.key;\n            field.fieldGroup = [\n                this.resolveMultiSchema('oneOf', schema.oneOf, { ...options, key, shareFormControl: false }),\n            ];\n        }\n        // map in possible formlyConfig options from the widget property\n        if (schema.widget?.formlyConfig) {\n            field = this.mergeFields(field, schema.widget.formlyConfig);\n        }\n        field.templateOptions = field.props;\n        // if there is a map function passed in, use it to allow the user to\n        // further customize how fields are being mapped\n        return options.map ? options.map(field, schema) : field;\n    }\n    resolveSchema(schema, options) {\n        if (schema && schema.$ref) {\n            schema = this.resolveDefinition(schema, options);\n        }\n        if (schema && schema.allOf) {\n            schema = this.resolveAllOf(schema, options);\n        }\n        return schema;\n    }\n    resolveAllOf({ allOf, ...baseSchema }, options) {\n        if (!allOf.length) {\n            throw Error(`allOf array can not be empty ${allOf}.`);\n        }\n        return allOf.reduce((base, schema) => {\n            schema = this.resolveSchema(schema, options);\n            if (base.required && schema.required) {\n                base.required = [...base.required, ...schema.required];\n            }\n            if (schema.uniqueItems) {\n                base.uniqueItems = schema.uniqueItems;\n            }\n            // resolve to min value\n            ['maxLength', 'maximum', 'exclusiveMaximum', 'maxItems', 'maxProperties'].forEach((prop) => {\n                if (!isEmpty(base[prop]) && !isEmpty(schema[prop])) {\n                    base[prop] = base[prop] < schema[prop] ? base[prop] : schema[prop];\n                }\n            });\n            // resolve to max value\n            ['minLength', 'minimum', 'exclusiveMinimum', 'minItems', 'minProperties'].forEach((prop) => {\n                if (!isEmpty(base[prop]) && !isEmpty(schema[prop])) {\n                    base[prop] = base[prop] > schema[prop] ? base[prop] : schema[prop];\n                }\n            });\n            return ɵreverseDeepMerge(base, schema);\n        }, baseSchema);\n    }\n    resolveMultiSchema(mode, schemas, options) {\n        return {\n            type: 'multischema',\n            fieldGroup: [\n                {\n                    type: 'enum',\n                    defaultValue: -1,\n                    props: {\n                        multiple: mode === 'anyOf',\n                        options: schemas.map((s, i) => ({ label: s.title, value: i, disabled: s.readOnly })),\n                    },\n                    hooks: {\n                        onInit: (f) => f.formControl.valueChanges.pipe(tap(() => f.options.detectChanges(f.parent))),\n                    },\n                },\n                {\n                    fieldGroup: schemas.map((s, i) => ({\n                        ...this._toFieldConfig(s, { ...options, resetOnHide: true }),\n                        expressions: {\n                            hide: (f, forceUpdate) => {\n                                const control = f.parent.parent.fieldGroup[0].formControl;\n                                if (control.value === -1 || forceUpdate) {\n                                    let value = f.parent.fieldGroup\n                                        .map((f, i) => [f, i, this.isFieldValid(f, i, schemas, options)])\n                                        .sort(([f1, , f1Valid], [f2, , f2Valid]) => {\n                                        if (f1Valid !== f2Valid) {\n                                            return f2Valid ? 1 : -1;\n                                        }\n                                        const matchedFields1 = totalMatchedFields(f1);\n                                        const matchedFields2 = totalMatchedFields(f2);\n                                        if (matchedFields1 === matchedFields2) {\n                                            if (f1.props.disabled === f2.props.disabled) {\n                                                return 0;\n                                            }\n                                            return matchedFields2 > matchedFields1 ? 1 : -1;\n                                        }\n                                        return matchedFields2 > matchedFields1 ? 1 : -1;\n                                    })\n                                        .map(([, i]) => i);\n                                    if (mode === 'anyOf') {\n                                        const definedValue = value.filter((i) => totalMatchedFields(f.parent.fieldGroup[i]));\n                                        value = definedValue.length > 0 ? definedValue : [value[0] || 0];\n                                    }\n                                    value = value.length > 0 ? value : [0];\n                                    control.setValue(mode === 'anyOf' ? value : value[0]);\n                                }\n                                return Array.isArray(control.value) ? control.value.indexOf(i) === -1 : control.value !== i;\n                            },\n                        },\n                    })),\n                },\n            ],\n        };\n    }\n    resolveDefinition(schema, options) {\n        const [uri, pointer] = schema.$ref.split('#/');\n        if (uri) {\n            throw Error(`Remote schemas for ${schema.$ref} not supported yet.`);\n        }\n        const definition = !pointer\n            ? null\n            : pointer\n                .split('/')\n                .reduce((def, path) => (def?.hasOwnProperty(path) ? def[path] : null), options.schema);\n        if (!definition) {\n            throw Error(`Cannot find a definition for ${schema.$ref}.`);\n        }\n        if (definition.$ref) {\n            return this.resolveDefinition(definition, options);\n        }\n        return {\n            ...definition,\n            ...['title', 'description', 'default', 'widget'].reduce((annotation, p) => {\n                if (schema.hasOwnProperty(p)) {\n                    annotation[p] = schema[p];\n                }\n                return annotation;\n            }, {}),\n        };\n    }\n    resolveDependencies(schema) {\n        const propDeps = {};\n        const schemaDeps = {};\n        Object.keys(schema.dependencies || {}).forEach((prop) => {\n            const dependency = schema.dependencies[prop];\n            if (Array.isArray(dependency)) {\n                // Property dependencies\n                dependency.forEach((dep) => {\n                    if (!propDeps[dep]) {\n                        propDeps[dep] = [prop];\n                    }\n                    else {\n                        propDeps[dep].push(prop);\n                    }\n                });\n            }\n            else {\n                // schema dependencies\n                schemaDeps[prop] = dependency;\n            }\n        });\n        return { propDeps, schemaDeps };\n    }\n    guessSchemaType(schema) {\n        const type = schema?.type;\n        if (!type && schema?.properties) {\n            return ['object'];\n        }\n        if (Array.isArray(type)) {\n            if (type.length === 1) {\n                return type;\n            }\n            if (type.length === 2 && type.indexOf('null') !== -1) {\n                return type.sort((t1) => (t1 == 'null' ? 1 : -1));\n            }\n            return type;\n        }\n        return type ? [type] : [];\n    }\n    addValidator(field, name, validator) {\n        field.validators = field.validators || {};\n        field.validators[name] = validator;\n    }\n    isEnum(schema) {\n        return (!!schema.enum ||\n            (schema.anyOf && schema.anyOf.every(isConst)) ||\n            (schema.oneOf && schema.oneOf.every(isConst)) ||\n            (schema.uniqueItems && schema.items && !Array.isArray(schema.items) && this.isEnum(schema.items)));\n    }\n    toEnumOptions(schema) {\n        if (schema.enum) {\n            return schema.enum.map((value) => ({ value, label: value }));\n        }\n        const toEnum = (s) => {\n            const value = s.hasOwnProperty('const') ? s.const : s.enum[0];\n            const option = { value, label: s.title || value };\n            if (s.readOnly) {\n                option.disabled = true;\n            }\n            return option;\n        };\n        if (schema.anyOf) {\n            return schema.anyOf.map(toEnum);\n        }\n        if (schema.oneOf) {\n            return schema.oneOf.map(toEnum);\n        }\n        return this.toEnumOptions(schema.items);\n    }\n    isFieldValid(root, i, schemas, options) {\n        if (!root._schemasFields) {\n            Object.defineProperty(root, '_schemasFields', { enumerable: false, writable: true, configurable: true });\n            root._schemasFields = {};\n        }\n        let field = root._schemasFields[i];\n        const model = root.model ? ɵclone(root.model) : root.fieldArray ? [] : {};\n        if (!field) {\n            field = root._schemasFields[i] = root.options.build({\n                form: Array.isArray(model) ? new FormArray([]) : new FormGroup({}),\n                fieldGroup: [\n                    this._toFieldConfig(schemas[i], {\n                        ...options,\n                        resetOnHide: true,\n                        ignoreDefault: true,\n                        map: null,\n                        strict: true,\n                    }),\n                ],\n                model,\n                options: {},\n            });\n        }\n        else {\n            field.model = model;\n            root.options.build(field);\n        }\n        return field.form.valid;\n    }\n    mergeFields(f1, f2) {\n        for (let prop in f2) {\n            const f1Prop = prop === 'templateOptions' ? 'props' : prop;\n            if (isObject(f1[f1Prop]) && isObject(f2[prop])) {\n                f1[f1Prop] = this.mergeFields(f1[f1Prop], f2[prop]);\n            }\n            else if (f2[prop] != null) {\n                f1[f1Prop] = f2[prop];\n            }\n        }\n        return f1;\n    }\n}\nFormlyJsonschema.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: FormlyJsonschema, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nFormlyJsonschema.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: FormlyJsonschema, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: i0, type: FormlyJsonschema, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { FormlyJsonschema };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}